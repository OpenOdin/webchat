<app>
    <hr />
    <!-- Set up flex container with screen limited to viewport and more pleasant font settings -->
    <div class="flex font-sans subpixel-antialiased h-screen">
        <div class="flex-none w-64 pb-6 hidden bg-bakgrund-3 md:block">
            <div class="flex mb-2 mt-3 px-4 text-rubriker justify-between">
                <div class="flex-auto">
                    <h1 class="mb-1 font-bold text-xl text-rubriker leading-snug truncate">
                        Space Chat
                    </h1>
                    <div class="h-5">
                    </div>
                    <div class="flex flex-row">
                        <button id="connectionModalButton" class="basis-1/5 -py-2 text-green-500 bg-white box-border w-10 border-2 border-green-500 shadow-lg shadow-green-400" type="button">
                            <img src={ state.picture } class="w-10 h-10">
                        </button>
                        <div class="basis-4/5 -px-8 ml-2">
                            <div class="flex flex-col font-bold">
                                <div class="text-underrubriker text-base opacity-80">
                                    { state.name }
                                </div>
                                <div class="w-40 text-underrubriker text-sm font-light italic opacity-80 truncate overflow-hidden text-ellipsis">
                                    { state.bio }
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="h-5">
                    </div>
                </div>
            </div>
            <div class="mb-8">
                <div class="px-4 mb-2 text-rubriker flex justify-between items-center">
                    <div class="opacity-75">
                        Active
                    </div>
                    <div>
                        <svg class="fill-current h-4 w-4 opacity-50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M3.204 5h9.592L8 10.481 3.204 5zm-.753.659 4.796 5.48a1 1 0 0 0 1.506 0l4.796-5.48c.566-.647.106-1.659-.753-1.659H3.204a1 1 0 0 0-.753 1.659z"/>
                        </svg>
                    </div>
                </div>
                <div each={ presence in state.presenceList } class="flex items-center mb-3 px-4">
                    <svg if={presence.active} class="h-2 w-2 mr-2 fill-current text-green-500" viewBox="0 0 20 20"
                        style="width: 22px">
                        <circle cx="10" cy="10" r="10">
                    </svg>
                    <svg if={!presence.active} class="h-2 w-2 stroke-current text-rubriker mr-2" viewBox="0 0 22 22"
                        style="width: 22px">
                        <circle cx="11" cy="11" r="9" fill="none" stroke-width="3">
                    </svg>
                    <span class="text-rubriker opacity-75"
                        style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        {presence.publicKey.toString("hex")}
                        <span if={ presence.isYou} class="px-2 text-gray-400 text-sm italic">you</span>
                    </span>
                </div>
            </div>

            <div class="mb-8">
                <div class="px-4 mb-2 text-rubriker flex justify-between items-center">
                    <div class="opacity-75">
                        Channels
                    </div>
                    <div>
                        <svg class="fill-current h-4 w-4 opacity-50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M11 9h4v2h-4v4H9v-4H5V9h4V5h2v4zm-1 11a10 10 0 1 1 0-20 10 10 0 0 1 0 20zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16z" />
                        </svg>
                    </div>
                </div>
                <div class="py-1 px-4 bg-lankar text-rubriker">
                    # SC2
                </div>
                <div class="py-1 px-4 text-rubriker">
                    # Random
                </div>
            </div>

            <div class="mb-8">
                <div class="flex px-4 mb-2 text-rubriker justify-between items-center">
                    <div class="opacity-75">
                        Direct Messages
                    </div>
                    <div>
                        <svg class="fill-current h-4 w-4 opacity-50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M14 8a4 4 0 1 0-8 0v7h8V8zM8.027 2.332A6.003 6.003 0 0 0 4 8v6l-3 2v1h18v-1l-3-2V8a6.003 6.003 0 0 0-4.027-5.668 2 2 0 1 0-3.945 0zM12 18a2 2 0 1 1-4 0h4z" fill-rule="evenodd" />
                        </svg>
                    </div>
                </div>

                <div class="flex items-center mb-3 px-4">
                    <svg class="h-2 w-2 mr-2 fill-current text-green-500" viewBox="0 0 20 20">
                        <circle cx="10" cy="10" r="10">
                    </svg>
                    <span class="text-rubriker opacity-75">
                        { state.name } <span class="px-2 text-gray-400 text-sm italic">you</span>
                    </span>
                </div>
                <div class="flex items-center mb-3 px-4">
                    <svg class="h-2 w-2 fill-current text-green-500 mr-2" viewBox="0 0 20 20">
                        <circle cx="10" cy="10" r="10">
                    </svg>
                    <span class="text-rubriker opacity-75">
                        Astro
                    </span>
                </div>
                <div class="flex items-center px-4 mb-3 opacity-50">
                    <svg class="h-2 w-2 stroke-current text-rubriker mr-2" viewBox="0 0 22 22">
                        <circle cx="11" cy="11" r="9" fill="none" stroke-width="3">
                    </svg>
                    <span class="text-underrubriker">
                        Astrochicken
                    </span>
                </div>
                <div class="flex items-center px-4 mb-6 opacity-50">
                    <svg class="h-2 w-2 stroke-current text-rubriker mr-2" viewBox="0 0 22 22">
                        <circle cx="11" cy="11" r="9" fill="none" stroke-width="3">
                    </svg>
                    <span class="text-underrubriker">
                        Roger Wilco
                    </span>
                </div>
            </div>

            <div>
                <div class="px-4 mb-2 text-rubriker flex justify-between items-center">
                    <div class="opacity-75">
                        Apps
                    </div>
                    <div>
                        <svg class="fill-current h-4 w-4 opacity-50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M11 9h4v2h-4v4H9v-4H5V9h4V5h2v4zm-1 11a10 10 0 1 1 0-20 10 10 0 0 1 0 20zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16z" />
                        </svg>
                    </div>
                </div>
                <div class="flex items-center px-4 mb-6 opacity-75">
                    <svg class="h-2 w-2 fill-current text-slate-50 mr-2" viewBox="0 0 22 22">
                        <path d="M32 16c0-8.837-7.163-16-16-16s-16 7.163-16 16 7.163 16 16 16 16-7.163 16-16zM3 16c0-7.18 5.82-13 13-13s13 5.82 13 13-5.82 13-13 13-13-5.82-13-13z"></path>
                        <path d="M9.914 11.086l-2.829 2.829 8.914 8.914 8.914-8.914-2.828-2.828-6.086 6.086z"></path>
                    </svg>
                    <span class="text-rubriker">
                        MyApp
                    </span>
                </div>
            </div>
        </div>

        <!-- Main area: chat -->
        <div id="chatArea" class="flex flex-1 flex-col bg-white overflow-hidden">
            <!-- Channel header -->
            <div class="bg-bakgrund-1 border-b flex px-6 py-2 items-center flex-none">
                <div class="flex flex-col">
                    <h3 class="text-rubriker mb-1 font-extrabold">
                        { state.chatAreaTitle }
                    </h3>
                    <div class="text-underrubriker text-normal text-sm truncate">
                        { state.chatAreaDescription }
                    </div>
                </div>

                <div class="flex flex-col">
                    <div if={state.error}>
                        <p>Error: {state.error}</p>
                    </div>

                    <div if={!state.universe.isActive()}
                        style="display: block; background-color: yellow;">

                        <h1>Please activate the UniverseAI Data Wallet browser extension
                            by clicking on the icon in your browser toolbar.</h1>
                    </div>

                    <button if={state.universe.isActive() && !state.walletAuth}
                        type="button" onclick={ auth }>

                        Authenticate with Data Wallet
                    </button>
                </div>

                <div class="ml-auto hidden md:block">
                    <div id="chatAreaSearch" class="relative">
                        <input type="search" placeholder="Search" class="appearance-none border border-gray-400 rounded-lg pl-8 pr-4 py-2">
                        <div class="absolute -mt-7 pin-y pin-l pl-3 flex items-center justify-center">
                            <svg class="fill-current text-gray-400 h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                                <path d="M12.9 14.32a8 8 0 1 1 1.41-1.41l5.35 5.33-1.42 1.42-5.33-5.34zM8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12z" />
                            </svg>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Messages -->
            <div id="messagesList" class="px-6 py-4 flex-1 overflow-y-scroll">
                <div each={ message in state.chatAreaMessages } class="flex items-start mb-4 text-base">
                    <div class="w-10 h-10 rounded mr-3">
                        <minidenticon-svg username={message.authorName} saturation="60" lightness="50"></minidenticon-svg>
                    </div>
                    <div class={ message.text.includes(state.searchTerm) ? "flex-1 -mt-1 overflow-hidden bg-yellow-300" : "flex-1 -mt-1 overflow-hidden" }>
                        <div>
                            <span class="font-bold">{ message.authorName }</span>
                            <span class="text-gray-400 text-xs ml-2">{ message.creationTimestamp }</span>
                        </div>
                        <p if={!message.hasBlob} class="text-black leading-normal"><raw html={ message.text }/></p>
                        <div if={message.hasBlob && !(message.imgSrc || message.attSrc)}>
                            Loading attachment...
                        </div>
                        <div if={message.imgSrc}>
                            <img src={message.imgSrc} title={message.msg}
                                style="max-height:240px;"
                            />
                        </div>
                        <div if={message.attSrc}>
                            Attachment:
                            <a href={message.attSrc} target="_blank"
                                style="color:blue;"
                                rel="noopener noreferrer">
                                {message.text || "Save attachment"}
                            </a>&nbsp;({message.blobLength} bytes)
                        </div>
                    </div>
                </div>
            </div>

            <div id="chatAreaInput" class="pb-6 px-4 flex-none">
                <div class="flex rounded-lg border-2 border-gray-500 overflow-hidden">
                    <label for="chatAreaInputFile" class="cursor-pointer text-3xl bg-blue-500 hove:bg-blue-700 font-bold text-gray-400 border-r-2 border-gray-400 p-2 focus:outline-none focus:shadow-outline">
                        <svg class="fill-current h-6 w-6 block" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M16 10c0 .553-.048 1-.601 1H11v4.399c0 .552-.447.601-1 .601-.553 0-1-.049-1-.601V11H4.601C4.049 11 4 10.553 4 10c0-.553.049-1 .601-1H9V4.601C9 4.048 9.447 4 10 4c.553 0 1 .048 1 .601V9h4.399c.553 0 .601.447.601 1z"/></svg>
                    </label>
                    <button id="chatAreaInputFileRemove" class="text-3xl text-red-600 border-r-2 border-gray-400 p-2 hidden" onclick={ clearMessageAndFileInputs }>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
                            <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                        </svg>
                    </button>
                    <input id="chatAreaNewMessage" type="text" class="w-full px-4 outline-double outline-gray-100" placeholder="Type message" />
                    <input type="file" id="chatAreaInputFile" accept="*/*" class="hidden">
                    <!--<p>PNG, GIF, JPEG, BMP, SVG, TIFF, WebP (max. 65KB)</p>-->
                    <button class="text-3xl text-gray-400 border-r-2 border-gray-400 p-2" onclick={ submitMessage }>
                        <svg class="fill-current h-6 w-6 block" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M17.218,2.268L2.477,8.388C2.13,8.535,2.164,9.05,2.542,9.134L9.33,10.67l1.535,6.787c0.083,0.377,0.602,0.415,0.745,0.065l6.123-14.74C17.866,2.46,17.539,2.134,17.218,2.268 M3.92,8.641l11.772-4.89L9.535,9.909L3.92,8.641z M11.358,16.078l-1.268-5.613l6.157-6.157L11.358,16.078z"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        import raw from "./raw.riot"

        import universeJson from "./universe.json";

        // Users show as inactive after this threshold.
        const INACTIVE_THRESHOLD = 5 * 6 * 1000;

        const MIME_TYPES = {
            "png":  "image/png",
            "gif":  "image/gif",
            "jpg":  "image/jpeg",
            "jpeg": "image/jpeg",
            "bmp":  "image/bmp",
            "svg":  "image/svg+xml",
            "tif":  "image/tiff",
            "tiff": "image/tiff",
            "webp": "image/webp",
        };

        export default {
            components: {
                raw
            },

            onBeforeMount(props, state) {
                ["mousemove", "keydown", "touchstart"].forEach( (eventName) => {
                    document.addEventListener(eventName, () => {
                        if (Date.now() - this.state.lastUIActive > INACTIVE_THRESHOLD) {
                            this.postPresence();
                        }

                        this.state.lastUIActive = Date.now();
                    }, true);
                });

                const universe = new this.props.Globals.Universe();

                universe.onActive( () => {
                    this.update();
                });

                this.state = {
                    universe,
                    presenceList: [],
                    lastUIActive: 0,
                };

                this.chatAreaResetInformation();
            },

            onUpdated() {
                var messagesList = document.getElementById("messagesList");
                if(messagesList) {
                    messagesList.scrollTop = messagesList.scrollHeight;
                }
            },

            async auth() {
                const rpcClients = await this.state.universe.auth();

                if (rpcClients.error) {
                    this.update({
                        error: rpcClients.error,
                    });

                    return;
                }

                const signatureOffloader        = rpcClients.signatureOffloader;
                const handshakeFactoryFactory   = rpcClients.handshakeFactoryFactory;
                const walletConf                = this.props.Globals.ParseUtil.ParseWalletConf({});  // TODO

                if (!handshakeFactoryFactory || !signatureOffloader) {
                    this.update({
                        error: "missing handshakeFactoryFactory | signatureOffloader",
                    });

                    return;
                }

                const publicKeys = await signatureOffloader.getPublicKeys();

                this.update({
                    walletAuth: {
                        signatureOffloader,
                        handshakeFactoryFactory,
                        publicKeys,
                        walletConf,
                    },
                });

                this.connect();
            },

            async connect() {
                if (this.state.service || !this.state.walletAuth) {
                    return;
                }

                const {publicKeys, signatureOffloader, handshakeFactoryFactory, walletConf} =
                    this.state.walletAuth;

                const universeConf = this.props.Globals.ParseUtil.ParseUniverseConf(universeJson);

                const service = new this.props.Globals.Service(universeConf, walletConf, signatureOffloader, handshakeFactoryFactory);

                try {
                    await service.init()
                }
                catch(e) {
                    signatureOffloader.close();
                    console.error("Could not init Service", e.message);

                    this.update({
                        error: "Could not init Service",
                    });

                    return;
                }

                service.onStop( () => {
                    signatureOffloader.close();

                    this.update({
                        service: undefined,
                    });
                });

                service.onStorageConnect( () => {
                    console.info("Connected to storage");
                    this.handleStorageConnect();
                });

                service.onStorageClose( () => {
                    console.error("Disconnected from storage");
                    this.handleStorageClose();

                });

                service.onConnectionError( (e) => {
                    console.info("Connection error", `${e.e.error}`);
                });

                service.onConnectionConnect( (e) => {
                    const pubKey = e.p2pClient.getRemotePublicKey();
                    console.info(`Peer just connected to service, peer's publicKey is ${pubKey.toString("hex")}`);
                });

                service.onConnectionClose( (e) => {
                    const pubKey = e.p2pClient.getRemotePublicKey();
                    console.info(`Peer disconnected, who has publicKey ${pubKey.toString("hex")}`);
                });

                this.update({
                    service,
                });

                service.start();
            },

            handleStorageConnect() {
                this.update({
                    connected: true,
                });

                this.openChannel();

                this.openPresence();
            },

            handleStorageClose() {
                this.update({
                    connected: false,
                });
            },

            openPresence() {
                const service = this.state.service;

                if (!service) {
                    return;
                }

                const thread = service.makeThread("presence");

                service.addThreadSync(thread);

                const query = thread.stream();

                query.onChange(this.handleIncomingPresence);

                this.state.presenceThread = thread;

                setInterval(this.refreshPresence, 5000);

                thread.post();

                this.state.presenceThread = thread;

                setInterval( () => {
                    if (Date.now() - this.state.lastUIActive < INACTIVE_THRESHOLD) {
                        this.postPresence();
                    }
                }, INACTIVE_THRESHOLD)
            },

            handleIncomingPresence(item, eventType) {
                const node = item.node;

                const publicKey = node.getOwner();
                const presenceList = this.state.presenceList;

                const presenceListLength = presenceList.length;
                let found = false;
                for (let i=0; i<presenceListLength; i++) {
                    const presence = presenceList[i];
                    if (presence.publicKey.equals(publicKey)) {
                        presence.pingTime = Date.now();
                        found = true;
                    }
                }

                if (!found) {
                    presenceList.push({
                        publicKey,
                        pingTime: Date.now(),
                        isYou: publicKey.equals(this.state.walletAuth.publicKeys[0]),
                        active: false,
                    });
                }

                this.refreshPresence();

                this.update();
            },

            postPresence() {
                this.state.presenceThread?.post();
            },

            refreshPresence() {
                const presenceList = this.state.presenceList;

                const presenceListLength = presenceList.length;

                let updated = false;
                for (let i=0; i<presenceListLength; i++) {
                    const presence = presenceList[i];

                    const active = Date.now() - presence.pingTime < INACTIVE_THRESHOLD * 1.25;

                    if (presence.active !== active) {
                        presence.active = active;
                        updated = true;
                    }
                }

                if (updated) {
                    this.update();
                }
            },

            openChannel(parentId) {
                const service = this.state.service;

                if (!service) {
                    return;
                }

                this.state.chatAreaMessages.length = 0;

                this.state.chatAreaMessages.push({
                    authorName: "Space informant",
                    creationTimestamp: new Date(),
                    text: "Authorized",
                });

                const channel = service.makeThread("messages", {parentId: Buffer.alloc(32)});

                service.addThreadSync(channel);

                const query = channel.stream();

                query.onChange(this.handleIncomingMessage);

                this.update({
                    channel,
                });
            },

            handleIncomingMessage(item, eventType) {
                const channel = this.state.channel;

                if (!channel) {
                    return;
                }

                if (eventType === "add" || eventType === "insert") {
                    const dataNode      = item.node;
                    const text          = dataNode.getData()?.toString();
                    const nodeId1       = dataNode.getId1();
                    const hasBlob       = dataNode.hasBlob();
                    const blobLength    = dataNode.getBlobLength();

                    const timestamp = new Date(dataNode.getCreationTime());

                    const autoDownload = true;

                    const message = {
                        authorName: dataNode.getOwner().toString("hex"),
                        creationTimestamp: timestamp,
                        text,
                        nodeId1,
                        hasBlob,
                        blobLength,
                        isDownloaded: false,
                        imgSrc: undefined,
                        attSrc: undefined,
                    };

                    if (eventType === "add") {
                        this.state.chatAreaMessages.push(message);
                    }
                    else {
                        this.state.chatAreaMessages.push(message);
                        /*this.state.chatAreaMessages.splice(index, 1, message);*/
                    }

                    if (hasBlob && autoDownload) {
                        // This is set to that we can follow the progress of the download in the UI.
                        message.streamReader = this.downloadFull(channel, dataNode, message);
                    }

                    this.update();
                }
                else if (eventType === "delete") {
                    // TODO
                }
            },

            downloadFull(thread, dataNode, message) {
                const {blobDataPromise, streamReader} = thread.downloadFull(dataNode);

                blobDataPromise.then(blobData => {
                    const nodeData = dataNode.getData();
                    let filename = "";

                    if(nodeData) {
                        filename = nodeData.toString();
                    }

                    const extension = filename.toLowerCase().split(".").pop();

                    const mimeType = MIME_TYPES[extension ?? ""] ?? "application/octet-stream";

                    const file = new File(blobData, filename, { type: mimeType });

                    const url = URL.createObjectURL(file);

                    if (mimeType.startsWith("image/")) {
                        message.imgSrc = url;
                    }
                    else {
                        message.attSrc = url;
                    }

                    this.update();
                });

                return streamReader;
            },

            async submitMessage(event) {
                event.preventDefault();

                if (!this.state.channel) {
                    return;
                }

                const messageElement = document.getElementById("chatAreaNewMessage");

                const message = messageElement.value;

                const fileElement = document.getElementById("chatAreaInputFile");
                const file = fileElement.files[0];

                this.clearMessageAndFileInputs();

                if (file) {
                    const filename = file.name;

                    const blobHash = await this.props.Globals.BrowserUtil.HashFileBrowser(file);

                    const blobLength = BigInt(file.size);

                    const [node] = await this.state.channel.post({
                            blobHash,
                            blobLength,
                            data: Buffer.from(filename),
                            contentType: "app/chat/attachment",
                        });

                    if (node) {
                        this.state.channel.postLicense(node);

                        const streamReader = new this.props.Globals.BrowserFileStreamReader(file);

                        this.state.channel.upload(node.getId1(), streamReader);

                        // TODO: show progress and detect errors on upload.
                    }
                }
                else {
                    const params = {data: Buffer.from(message)};

                    const [node] = await this.state.channel.post(params);

                    if (node) {
                        this.state.channel.postLicense(node);
                    }
                }
            },

            onMounted(props, state) {
                // Register <ENTER> key press as shortcut to submitMessage action
                document.getElementById("chatAreaNewMessage").addEventListener("keypress", (event) => {
                    if(event.key == "Enter") {
                        this.submitMessage(event);
                    }
                });

                // Register file input dialog change event
                document.getElementById("chatAreaInputFile").addEventListener("change", (event) => {
                    var file = event.target.files[0];
                    if(file) {
                        let messageElement = document.getElementById("chatAreaNewMessage");
                        if(messageElement) {
                            messageElement.value = file.name;
                            messageElement.disabled = true;
                            var fileElementRemove = document.getElementById("chatAreaInputFileRemove");
                            fileElementRemove.classList.remove("hidden");
                        }

                        this.update();
                    }
                 });
            },

            chatAreaResetInformation() {
                this.state.chatAreaTitle = "No chat room selected";
                this.state.chatAreaDescription="Join a conversation by selecting a chat room";
                var date = new Date();
                var timestamp = date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
                this.state.chatAreaMessages = [
                    {
                        authorName: "Space informant",
                        creationTimestamp: timestamp,
                        text: "[NOTICE] - Not connected. Connect by clicking Connect button above."
                    }
                ];
            },

            clearMessageAndFileInputs(event) {
                var messageElement = document.getElementById("chatAreaNewMessage");
                messageElement.value = "";
                messageElement.disabled = false;

                var fileElement = document.getElementById("chatAreaInputFile");
                fileElement.value = "";
                var fileElementRemove = document.getElementById("chatAreaInputFileRemove");
                fileElementRemove.classList.add("hidden");
            }
        }
    </script>
</app>
